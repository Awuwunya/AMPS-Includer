using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Includer {
	class Program {
		static readonly Func<string, int> ConvAssembler = (s) => {
			switch (s.ToUpperInvariant()) {
				case "AS": return 1;
				case "ASM68K": return 0;
			}

			Console.Write("Invalid assembler " + s + "!");
			Console.ReadKey();
			Environment.Exit(-1);
			return 0;
		};

		static void Main(string[] args) {
			if(args.Length < 3) {
				Console.Write(
					"Usage: \"AMPS Includer\" <assembler> <input folder> <output file>\n"+
					"<assembler> :    The assembler being targeted, either AS or ASM68K\n"+
					"<input folder> : The file path for the folder containing AMPS\n" +
					"<output file> :  The file path for the output file generated by this tool\n\n"+
					"This tool was mainly created to help with compatibility between multiple\n"+
					"different assemblers, as using macros alone provided extremely difficult.\n"+
					"This tool will generate code that will help manage file includes in a more\n"+
					"sensible and portable manner."
				);

				Console.ReadKey();
				return;
			}

			// figure out the assembler
			int assembler = ConvAssembler(args[0]);

			string set = new string[] { "=", ":=" }[assembler];
			string equ = new string[] { "equ", "=" }[assembler];
			string include = new string[] { "include", "include" }[assembler];
			string even = new string[] { "even", "align 2" }[assembler];

			// figure out if arguments are ok
			if (File.Exists(args[2])) File.Delete(args[2]);
			if (!args[1].EndsWith("/") && !args[1].EndsWith("\\")) args[1] += "/";

			if(!File.Exists(args[1] + "code/Data.asm")) {
				Console.Write("Could not locate Data.asm. Make sure the input folder is correct");
				Console.ReadKey();
				return;
			}
 
			try {
				string file = File.ReadAllText(args[1] + "code/Data.asm");
				string fileinc = "\n", sfxinc = "\n";

				// find each included music in file
				MatchCollection mc = MusRex.Matches(file);
				
				foreach(Match m in mc) {
					if(m.Groups.Count > 0) {
						// possible match, investigate
						string rep = "\n";
						string[] a = m.Groups[1].Value.Split(',');

						// check if uneven amount of arguments
						if((a.Length & 1) != 0) {
							Console.WriteLine("Error, line is missing argument for music tempo!");
							Console.WriteLine(m.Value);
							Console.ReadKey();
							return;
						}

						// build up strings
						for(int i = 0;i < a.Length; i += 2) {
							fileinc += "\t\t"+ even +"\n_mus_" + a[i].Trim() + ":\t"+ include +" \"" + args[1] + "music/" + a[i].Trim() + ".s2a\"\n";
							rep += "mus_"+ a[i].Trim() + " "+ equ +"\t__mus\n__mus "+ set + "\t__mus+1\n\t\tdc.l ((" + a[i + 1].Trim() + ")<<24)|_mus_" + a[i].Trim() +"\n";
						}

						// replace current thing right now
						int ix = m.Value.IndexOf("ptrmusic", StringComparison.InvariantCultureIgnoreCase);
						file = file.Replace(m.Value, rep);
					}
				}

				// find each included sfx in file
				mc = SndRex.Matches(file);

				foreach (Match m in mc) {
					if (m.Groups.Count > 1) {
						// possible match, investigate
						string rep = "\n";
						string val = m.Groups[1].Value.Trim();
						string[] a = m.Groups[2].Value.Split(',');

						// build up strings
						for (int i = 0;i < a.Length;i ++) {
							sfxinc += "\t\t" + even + "\n_sfx_" + a[i].Trim() + ":\t" + include + " \"" + args[1] + "sfx/" + a[i].Trim() + ".s2a\"\n";
							rep += "sfx_" + a[i].Trim() + " " + equ + "\t__sfx\n__sfx " + set + "\t__sfx+1\n\t\tdc.l ((" + val + ")<<24)|_sfx_" + a[i].Trim() + "\n";
						}

						// replace current thing right now
						int ix = m.Value.IndexOf("ptrsfx", StringComparison.InvariantCultureIgnoreCase);
						file = file.Replace(m.Value.Substring(ix), rep);
					}
				}

				// find the music pointer stuff
				mc = MusIncRex.Matches(file);

				foreach (Match m in mc) {
					// replace with the file include contents
					int ix = m.Value.IndexOf("incmus", StringComparison.InvariantCultureIgnoreCase);
					file = file.Replace(m.Value.Substring(ix), fileinc);
				}

				// find the sfx pointer stuff
				mc = SndIncRex.Matches(file);

				foreach (Match m in mc) {
					// replace with the file include contents
					int ix = m.Value.IndexOf("incsfx", StringComparison.InvariantCultureIgnoreCase);
					file = file.Replace(m.Value.Substring(ix), sfxinc);
				}

				// write file
				File.WriteAllText(args[2], file);

			} catch(Exception e) {
				Console.WriteLine(e);
				Console.ReadKey();
			}
		}

		readonly static RegexOptions Options = RegexOptions.CultureInvariant | RegexOptions.IgnoreCase | RegexOptions.Multiline;
		readonly static Regex MusRex = new Regex(@"^[a-z0-9_:]*[\t ]*ptrmusic[\t ]*([a-z0-9_,\t \$+\-*/&|^]*)", RegexOptions.Compiled | Options);
		readonly static Regex SndRex = new Regex(@"^[a-z0-9_:]*[\t ]*ptrsfx[\t ]*(\$?[0-9a-f+\-*/&|^]*),[\t ]*([a-z0-9_,\t \$+\-*/&|^]*)", RegexOptions.Compiled | Options);
		readonly static Regex MusIncRex = new Regex(@"^[a-z0-9_:]*[\t ]*incmus", Options);
		readonly static Regex SndIncRex = new Regex(@"^[a-z0-9_:]*[\t ]*incsfx", Options);
	}
}
